// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package builder

//go:generate minimock -i github.com/etilite/xlsx-builder/internal/builder.streamWriter -o zzz_stream_writer_mock_test.go -n StreamWriterMock -p builder

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/xuri/excelize/v2"
)

// StreamWriterMock implements streamWriter
type StreamWriterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFlush          func() (err error)
	inspectFuncFlush   func()
	afterFlushCounter  uint64
	beforeFlushCounter uint64
	FlushMock          mStreamWriterMockFlush

	funcSetRow          func(cell string, values []interface{}, opts ...excelize.RowOpts) (err error)
	inspectFuncSetRow   func(cell string, values []interface{}, opts ...excelize.RowOpts)
	afterSetRowCounter  uint64
	beforeSetRowCounter uint64
	SetRowMock          mStreamWriterMockSetRow
}

// NewStreamWriterMock returns a mock for streamWriter
func NewStreamWriterMock(t minimock.Tester) *StreamWriterMock {
	m := &StreamWriterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FlushMock = mStreamWriterMockFlush{mock: m}

	m.SetRowMock = mStreamWriterMockSetRow{mock: m}
	m.SetRowMock.callArgs = []*StreamWriterMockSetRowParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStreamWriterMockFlush struct {
	optional           bool
	mock               *StreamWriterMock
	defaultExpectation *StreamWriterMockFlushExpectation
	expectations       []*StreamWriterMockFlushExpectation

	expectedInvocations uint64
}

// StreamWriterMockFlushExpectation specifies expectation struct of the streamWriter.Flush
type StreamWriterMockFlushExpectation struct {
	mock *StreamWriterMock

	results *StreamWriterMockFlushResults
	Counter uint64
}

// StreamWriterMockFlushResults contains results of the streamWriter.Flush
type StreamWriterMockFlushResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFlush *mStreamWriterMockFlush) Optional() *mStreamWriterMockFlush {
	mmFlush.optional = true
	return mmFlush
}

// Expect sets up expected params for streamWriter.Flush
func (mmFlush *mStreamWriterMockFlush) Expect() *mStreamWriterMockFlush {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("StreamWriterMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &StreamWriterMockFlushExpectation{}
	}

	return mmFlush
}

// Inspect accepts an inspector function that has same arguments as the streamWriter.Flush
func (mmFlush *mStreamWriterMockFlush) Inspect(f func()) *mStreamWriterMockFlush {
	if mmFlush.mock.inspectFuncFlush != nil {
		mmFlush.mock.t.Fatalf("Inspect function is already set for StreamWriterMock.Flush")
	}

	mmFlush.mock.inspectFuncFlush = f

	return mmFlush
}

// Return sets up results that will be returned by streamWriter.Flush
func (mmFlush *mStreamWriterMockFlush) Return(err error) *StreamWriterMock {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("StreamWriterMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &StreamWriterMockFlushExpectation{mock: mmFlush.mock}
	}
	mmFlush.defaultExpectation.results = &StreamWriterMockFlushResults{err}
	return mmFlush.mock
}

// Set uses given function f to mock the streamWriter.Flush method
func (mmFlush *mStreamWriterMockFlush) Set(f func() (err error)) *StreamWriterMock {
	if mmFlush.defaultExpectation != nil {
		mmFlush.mock.t.Fatalf("Default expectation is already set for the streamWriter.Flush method")
	}

	if len(mmFlush.expectations) > 0 {
		mmFlush.mock.t.Fatalf("Some expectations are already set for the streamWriter.Flush method")
	}

	mmFlush.mock.funcFlush = f
	return mmFlush.mock
}

// Times sets number of times streamWriter.Flush should be invoked
func (mmFlush *mStreamWriterMockFlush) Times(n uint64) *mStreamWriterMockFlush {
	if n == 0 {
		mmFlush.mock.t.Fatalf("Times of StreamWriterMock.Flush mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFlush.expectedInvocations, n)
	return mmFlush
}

func (mmFlush *mStreamWriterMockFlush) invocationsDone() bool {
	if len(mmFlush.expectations) == 0 && mmFlush.defaultExpectation == nil && mmFlush.mock.funcFlush == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFlush.mock.afterFlushCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFlush.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Flush implements streamWriter
func (mmFlush *StreamWriterMock) Flush() (err error) {
	mm_atomic.AddUint64(&mmFlush.beforeFlushCounter, 1)
	defer mm_atomic.AddUint64(&mmFlush.afterFlushCounter, 1)

	if mmFlush.inspectFuncFlush != nil {
		mmFlush.inspectFuncFlush()
	}

	if mmFlush.FlushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlush.FlushMock.defaultExpectation.Counter, 1)

		mm_results := mmFlush.FlushMock.defaultExpectation.results
		if mm_results == nil {
			mmFlush.t.Fatal("No results are set for the StreamWriterMock.Flush")
		}
		return (*mm_results).err
	}
	if mmFlush.funcFlush != nil {
		return mmFlush.funcFlush()
	}
	mmFlush.t.Fatalf("Unexpected call to StreamWriterMock.Flush.")
	return
}

// FlushAfterCounter returns a count of finished StreamWriterMock.Flush invocations
func (mmFlush *StreamWriterMock) FlushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.afterFlushCounter)
}

// FlushBeforeCounter returns a count of StreamWriterMock.Flush invocations
func (mmFlush *StreamWriterMock) FlushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.beforeFlushCounter)
}

// MinimockFlushDone returns true if the count of the Flush invocations corresponds
// the number of defined expectations
func (m *StreamWriterMock) MinimockFlushDone() bool {
	if m.FlushMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FlushMock.invocationsDone()
}

// MinimockFlushInspect logs each unmet expectation
func (m *StreamWriterMock) MinimockFlushInspect() {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamWriterMock.Flush")
		}
	}

	afterFlushCounter := mm_atomic.LoadUint64(&m.afterFlushCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && afterFlushCounter < 1 {
		m.t.Error("Expected call to StreamWriterMock.Flush")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && afterFlushCounter < 1 {
		m.t.Error("Expected call to StreamWriterMock.Flush")
	}

	if !m.FlushMock.invocationsDone() && afterFlushCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamWriterMock.Flush but found %d calls",
			mm_atomic.LoadUint64(&m.FlushMock.expectedInvocations), afterFlushCounter)
	}
}

type mStreamWriterMockSetRow struct {
	optional           bool
	mock               *StreamWriterMock
	defaultExpectation *StreamWriterMockSetRowExpectation
	expectations       []*StreamWriterMockSetRowExpectation

	callArgs []*StreamWriterMockSetRowParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamWriterMockSetRowExpectation specifies expectation struct of the streamWriter.SetRow
type StreamWriterMockSetRowExpectation struct {
	mock      *StreamWriterMock
	params    *StreamWriterMockSetRowParams
	paramPtrs *StreamWriterMockSetRowParamPtrs
	results   *StreamWriterMockSetRowResults
	Counter   uint64
}

// StreamWriterMockSetRowParams contains parameters of the streamWriter.SetRow
type StreamWriterMockSetRowParams struct {
	cell   string
	values []interface{}
	opts   []excelize.RowOpts
}

// StreamWriterMockSetRowParamPtrs contains pointers to parameters of the streamWriter.SetRow
type StreamWriterMockSetRowParamPtrs struct {
	cell   *string
	values *[]interface{}
	opts   *[]excelize.RowOpts
}

// StreamWriterMockSetRowResults contains results of the streamWriter.SetRow
type StreamWriterMockSetRowResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetRow *mStreamWriterMockSetRow) Optional() *mStreamWriterMockSetRow {
	mmSetRow.optional = true
	return mmSetRow
}

// Expect sets up expected params for streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) Expect(cell string, values []interface{}, opts ...excelize.RowOpts) *mStreamWriterMockSetRow {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	if mmSetRow.defaultExpectation == nil {
		mmSetRow.defaultExpectation = &StreamWriterMockSetRowExpectation{}
	}

	if mmSetRow.defaultExpectation.paramPtrs != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by ExpectParams functions")
	}

	mmSetRow.defaultExpectation.params = &StreamWriterMockSetRowParams{cell, values, opts}
	for _, e := range mmSetRow.expectations {
		if minimock.Equal(e.params, mmSetRow.defaultExpectation.params) {
			mmSetRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRow.defaultExpectation.params)
		}
	}

	return mmSetRow
}

// ExpectCellParam1 sets up expected param cell for streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) ExpectCellParam1(cell string) *mStreamWriterMockSetRow {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	if mmSetRow.defaultExpectation == nil {
		mmSetRow.defaultExpectation = &StreamWriterMockSetRowExpectation{}
	}

	if mmSetRow.defaultExpectation.params != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Expect")
	}

	if mmSetRow.defaultExpectation.paramPtrs == nil {
		mmSetRow.defaultExpectation.paramPtrs = &StreamWriterMockSetRowParamPtrs{}
	}
	mmSetRow.defaultExpectation.paramPtrs.cell = &cell

	return mmSetRow
}

// ExpectValuesParam2 sets up expected param values for streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) ExpectValuesParam2(values []interface{}) *mStreamWriterMockSetRow {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	if mmSetRow.defaultExpectation == nil {
		mmSetRow.defaultExpectation = &StreamWriterMockSetRowExpectation{}
	}

	if mmSetRow.defaultExpectation.params != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Expect")
	}

	if mmSetRow.defaultExpectation.paramPtrs == nil {
		mmSetRow.defaultExpectation.paramPtrs = &StreamWriterMockSetRowParamPtrs{}
	}
	mmSetRow.defaultExpectation.paramPtrs.values = &values

	return mmSetRow
}

// ExpectOptsParam3 sets up expected param opts for streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) ExpectOptsParam3(opts ...excelize.RowOpts) *mStreamWriterMockSetRow {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	if mmSetRow.defaultExpectation == nil {
		mmSetRow.defaultExpectation = &StreamWriterMockSetRowExpectation{}
	}

	if mmSetRow.defaultExpectation.params != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Expect")
	}

	if mmSetRow.defaultExpectation.paramPtrs == nil {
		mmSetRow.defaultExpectation.paramPtrs = &StreamWriterMockSetRowParamPtrs{}
	}
	mmSetRow.defaultExpectation.paramPtrs.opts = &opts

	return mmSetRow
}

// Inspect accepts an inspector function that has same arguments as the streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) Inspect(f func(cell string, values []interface{}, opts ...excelize.RowOpts)) *mStreamWriterMockSetRow {
	if mmSetRow.mock.inspectFuncSetRow != nil {
		mmSetRow.mock.t.Fatalf("Inspect function is already set for StreamWriterMock.SetRow")
	}

	mmSetRow.mock.inspectFuncSetRow = f

	return mmSetRow
}

// Return sets up results that will be returned by streamWriter.SetRow
func (mmSetRow *mStreamWriterMockSetRow) Return(err error) *StreamWriterMock {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	if mmSetRow.defaultExpectation == nil {
		mmSetRow.defaultExpectation = &StreamWriterMockSetRowExpectation{mock: mmSetRow.mock}
	}
	mmSetRow.defaultExpectation.results = &StreamWriterMockSetRowResults{err}
	return mmSetRow.mock
}

// Set uses given function f to mock the streamWriter.SetRow method
func (mmSetRow *mStreamWriterMockSetRow) Set(f func(cell string, values []interface{}, opts ...excelize.RowOpts) (err error)) *StreamWriterMock {
	if mmSetRow.defaultExpectation != nil {
		mmSetRow.mock.t.Fatalf("Default expectation is already set for the streamWriter.SetRow method")
	}

	if len(mmSetRow.expectations) > 0 {
		mmSetRow.mock.t.Fatalf("Some expectations are already set for the streamWriter.SetRow method")
	}

	mmSetRow.mock.funcSetRow = f
	return mmSetRow.mock
}

// When sets expectation for the streamWriter.SetRow which will trigger the result defined by the following
// Then helper
func (mmSetRow *mStreamWriterMockSetRow) When(cell string, values []interface{}, opts ...excelize.RowOpts) *StreamWriterMockSetRowExpectation {
	if mmSetRow.mock.funcSetRow != nil {
		mmSetRow.mock.t.Fatalf("StreamWriterMock.SetRow mock is already set by Set")
	}

	expectation := &StreamWriterMockSetRowExpectation{
		mock:   mmSetRow.mock,
		params: &StreamWriterMockSetRowParams{cell, values, opts},
	}
	mmSetRow.expectations = append(mmSetRow.expectations, expectation)
	return expectation
}

// Then sets up streamWriter.SetRow return parameters for the expectation previously defined by the When method
func (e *StreamWriterMockSetRowExpectation) Then(err error) *StreamWriterMock {
	e.results = &StreamWriterMockSetRowResults{err}
	return e.mock
}

// Times sets number of times streamWriter.SetRow should be invoked
func (mmSetRow *mStreamWriterMockSetRow) Times(n uint64) *mStreamWriterMockSetRow {
	if n == 0 {
		mmSetRow.mock.t.Fatalf("Times of StreamWriterMock.SetRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetRow.expectedInvocations, n)
	return mmSetRow
}

func (mmSetRow *mStreamWriterMockSetRow) invocationsDone() bool {
	if len(mmSetRow.expectations) == 0 && mmSetRow.defaultExpectation == nil && mmSetRow.mock.funcSetRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetRow.mock.afterSetRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetRow implements streamWriter
func (mmSetRow *StreamWriterMock) SetRow(cell string, values []interface{}, opts ...excelize.RowOpts) (err error) {
	mm_atomic.AddUint64(&mmSetRow.beforeSetRowCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRow.afterSetRowCounter, 1)

	if mmSetRow.inspectFuncSetRow != nil {
		mmSetRow.inspectFuncSetRow(cell, values, opts...)
	}

	mm_params := StreamWriterMockSetRowParams{cell, values, opts}

	// Record call args
	mmSetRow.SetRowMock.mutex.Lock()
	mmSetRow.SetRowMock.callArgs = append(mmSetRow.SetRowMock.callArgs, &mm_params)
	mmSetRow.SetRowMock.mutex.Unlock()

	for _, e := range mmSetRow.SetRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetRow.SetRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRow.SetRowMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRow.SetRowMock.defaultExpectation.params
		mm_want_ptrs := mmSetRow.SetRowMock.defaultExpectation.paramPtrs

		mm_got := StreamWriterMockSetRowParams{cell, values, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.cell != nil && !minimock.Equal(*mm_want_ptrs.cell, mm_got.cell) {
				mmSetRow.t.Errorf("StreamWriterMock.SetRow got unexpected parameter cell, want: %#v, got: %#v%s\n", *mm_want_ptrs.cell, mm_got.cell, minimock.Diff(*mm_want_ptrs.cell, mm_got.cell))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmSetRow.t.Errorf("StreamWriterMock.SetRow got unexpected parameter values, want: %#v, got: %#v%s\n", *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSetRow.t.Errorf("StreamWriterMock.SetRow got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRow.t.Errorf("StreamWriterMock.SetRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetRow.SetRowMock.defaultExpectation.results
		if mm_results == nil {
			mmSetRow.t.Fatal("No results are set for the StreamWriterMock.SetRow")
		}
		return (*mm_results).err
	}
	if mmSetRow.funcSetRow != nil {
		return mmSetRow.funcSetRow(cell, values, opts...)
	}
	mmSetRow.t.Fatalf("Unexpected call to StreamWriterMock.SetRow. %v %v %v", cell, values, opts)
	return
}

// SetRowAfterCounter returns a count of finished StreamWriterMock.SetRow invocations
func (mmSetRow *StreamWriterMock) SetRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRow.afterSetRowCounter)
}

// SetRowBeforeCounter returns a count of StreamWriterMock.SetRow invocations
func (mmSetRow *StreamWriterMock) SetRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRow.beforeSetRowCounter)
}

// Calls returns a list of arguments used in each call to StreamWriterMock.SetRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRow *mStreamWriterMockSetRow) Calls() []*StreamWriterMockSetRowParams {
	mmSetRow.mutex.RLock()

	argCopy := make([]*StreamWriterMockSetRowParams, len(mmSetRow.callArgs))
	copy(argCopy, mmSetRow.callArgs)

	mmSetRow.mutex.RUnlock()

	return argCopy
}

// MinimockSetRowDone returns true if the count of the SetRow invocations corresponds
// the number of defined expectations
func (m *StreamWriterMock) MinimockSetRowDone() bool {
	if m.SetRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetRowMock.invocationsDone()
}

// MinimockSetRowInspect logs each unmet expectation
func (m *StreamWriterMock) MinimockSetRowInspect() {
	for _, e := range m.SetRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamWriterMock.SetRow with params: %#v", *e.params)
		}
	}

	afterSetRowCounter := mm_atomic.LoadUint64(&m.afterSetRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetRowMock.defaultExpectation != nil && afterSetRowCounter < 1 {
		if m.SetRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamWriterMock.SetRow")
		} else {
			m.t.Errorf("Expected call to StreamWriterMock.SetRow with params: %#v", *m.SetRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRow != nil && afterSetRowCounter < 1 {
		m.t.Error("Expected call to StreamWriterMock.SetRow")
	}

	if !m.SetRowMock.invocationsDone() && afterSetRowCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamWriterMock.SetRow but found %d calls",
			mm_atomic.LoadUint64(&m.SetRowMock.expectedInvocations), afterSetRowCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StreamWriterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFlushInspect()

			m.MinimockSetRowInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StreamWriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StreamWriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFlushDone() &&
		m.MinimockSetRowDone()
}
