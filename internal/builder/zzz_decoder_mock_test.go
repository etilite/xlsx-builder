// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package builder

//go:generate minimock -i github.com/etilite/xlsx-builder/internal/builder.decoder -o zzz_decoder_mock_test.go -n DecoderMock -p builder

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DecoderMock implements decoder
type DecoderMock[T any] struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDecodeAndProcess          func(r io.Reader, process func(T) error) (err error)
	inspectFuncDecodeAndProcess   func(r io.Reader, process func(T) error)
	afterDecodeAndProcessCounter  uint64
	beforeDecodeAndProcessCounter uint64
	DecodeAndProcessMock          mDecoderMockDecodeAndProcess[T]
}

// NewDecoderMock returns a mock for decoder
func NewDecoderMock[T any](t minimock.Tester) *DecoderMock[T] {
	m := &DecoderMock[T]{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DecodeAndProcessMock = mDecoderMockDecodeAndProcess[T]{mock: m}
	m.DecodeAndProcessMock.callArgs = []*DecoderMockDecodeAndProcessParams[T]{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDecoderMockDecodeAndProcess[T any] struct {
	optional           bool
	mock               *DecoderMock[T]
	defaultExpectation *DecoderMockDecodeAndProcessExpectation[T]
	expectations       []*DecoderMockDecodeAndProcessExpectation[T]

	callArgs []*DecoderMockDecodeAndProcessParams[T]
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// DecoderMockDecodeAndProcessExpectation specifies expectation struct of the decoder.DecodeAndProcess
type DecoderMockDecodeAndProcessExpectation[T any] struct {
	mock      *DecoderMock[T]
	params    *DecoderMockDecodeAndProcessParams[T]
	paramPtrs *DecoderMockDecodeAndProcessParamPtrs[T]
	results   *DecoderMockDecodeAndProcessResults[T]
	Counter   uint64
}

// DecoderMockDecodeAndProcessParams contains parameters of the decoder.DecodeAndProcess
type DecoderMockDecodeAndProcessParams[T any] struct {
	r       io.Reader
	process func(T) error
}

// DecoderMockDecodeAndProcessParamPtrs contains pointers to parameters of the decoder.DecodeAndProcess
type DecoderMockDecodeAndProcessParamPtrs[T any] struct {
	r       *io.Reader
	process *func(T) error
}

// DecoderMockDecodeAndProcessResults contains results of the decoder.DecodeAndProcess
type DecoderMockDecodeAndProcessResults[T any] struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Optional() *mDecoderMockDecodeAndProcess[T] {
	mmDecodeAndProcess.optional = true
	return mmDecodeAndProcess
}

// Expect sets up expected params for decoder.DecodeAndProcess
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Expect(r io.Reader, process func(T) error) *mDecoderMockDecodeAndProcess[T] {
	if mmDecodeAndProcess.mock.funcDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Set")
	}

	if mmDecodeAndProcess.defaultExpectation == nil {
		mmDecodeAndProcess.defaultExpectation = &DecoderMockDecodeAndProcessExpectation[T]{}
	}

	if mmDecodeAndProcess.defaultExpectation.paramPtrs != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by ExpectParams functions")
	}

	mmDecodeAndProcess.defaultExpectation.params = &DecoderMockDecodeAndProcessParams[T]{r, process}
	for _, e := range mmDecodeAndProcess.expectations {
		if minimock.Equal(e.params, mmDecodeAndProcess.defaultExpectation.params) {
			mmDecodeAndProcess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecodeAndProcess.defaultExpectation.params)
		}
	}

	return mmDecodeAndProcess
}

// ExpectRParam1 sets up expected param r for decoder.DecodeAndProcess
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) ExpectRParam1(r io.Reader) *mDecoderMockDecodeAndProcess[T] {
	if mmDecodeAndProcess.mock.funcDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Set")
	}

	if mmDecodeAndProcess.defaultExpectation == nil {
		mmDecodeAndProcess.defaultExpectation = &DecoderMockDecodeAndProcessExpectation[T]{}
	}

	if mmDecodeAndProcess.defaultExpectation.params != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Expect")
	}

	if mmDecodeAndProcess.defaultExpectation.paramPtrs == nil {
		mmDecodeAndProcess.defaultExpectation.paramPtrs = &DecoderMockDecodeAndProcessParamPtrs[T]{}
	}
	mmDecodeAndProcess.defaultExpectation.paramPtrs.r = &r

	return mmDecodeAndProcess
}

// ExpectProcessParam2 sets up expected param process for decoder.DecodeAndProcess
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) ExpectProcessParam2(process func(T) error) *mDecoderMockDecodeAndProcess[T] {
	if mmDecodeAndProcess.mock.funcDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Set")
	}

	if mmDecodeAndProcess.defaultExpectation == nil {
		mmDecodeAndProcess.defaultExpectation = &DecoderMockDecodeAndProcessExpectation[T]{}
	}

	if mmDecodeAndProcess.defaultExpectation.params != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Expect")
	}

	if mmDecodeAndProcess.defaultExpectation.paramPtrs == nil {
		mmDecodeAndProcess.defaultExpectation.paramPtrs = &DecoderMockDecodeAndProcessParamPtrs[T]{}
	}
	mmDecodeAndProcess.defaultExpectation.paramPtrs.process = &process

	return mmDecodeAndProcess
}

// Inspect accepts an inspector function that has same arguments as the decoder.DecodeAndProcess
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Inspect(f func(r io.Reader, process func(T) error)) *mDecoderMockDecodeAndProcess[T] {
	if mmDecodeAndProcess.mock.inspectFuncDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("Inspect function is already set for DecoderMock.DecodeAndProcess")
	}

	mmDecodeAndProcess.mock.inspectFuncDecodeAndProcess = f

	return mmDecodeAndProcess
}

// Return sets up results that will be returned by decoder.DecodeAndProcess
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Return(err error) *DecoderMock[T] {
	if mmDecodeAndProcess.mock.funcDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Set")
	}

	if mmDecodeAndProcess.defaultExpectation == nil {
		mmDecodeAndProcess.defaultExpectation = &DecoderMockDecodeAndProcessExpectation[T]{mock: mmDecodeAndProcess.mock}
	}
	mmDecodeAndProcess.defaultExpectation.results = &DecoderMockDecodeAndProcessResults[T]{err}
	return mmDecodeAndProcess.mock
}

// Set uses given function f to mock the decoder.DecodeAndProcess method
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Set(f func(r io.Reader, process func(T) error) (err error)) *DecoderMock[T] {
	if mmDecodeAndProcess.defaultExpectation != nil {
		mmDecodeAndProcess.mock.t.Fatalf("Default expectation is already set for the decoder.DecodeAndProcess method")
	}

	if len(mmDecodeAndProcess.expectations) > 0 {
		mmDecodeAndProcess.mock.t.Fatalf("Some expectations are already set for the decoder.DecodeAndProcess method")
	}

	mmDecodeAndProcess.mock.funcDecodeAndProcess = f
	return mmDecodeAndProcess.mock
}

// When sets expectation for the decoder.DecodeAndProcess which will trigger the result defined by the following
// Then helper
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) When(r io.Reader, process func(T) error) *DecoderMockDecodeAndProcessExpectation[T] {
	if mmDecodeAndProcess.mock.funcDecodeAndProcess != nil {
		mmDecodeAndProcess.mock.t.Fatalf("DecoderMock.DecodeAndProcess mock is already set by Set")
	}

	expectation := &DecoderMockDecodeAndProcessExpectation[T]{
		mock:   mmDecodeAndProcess.mock,
		params: &DecoderMockDecodeAndProcessParams[T]{r, process},
	}
	mmDecodeAndProcess.expectations = append(mmDecodeAndProcess.expectations, expectation)
	return expectation
}

// Then sets up decoder.DecodeAndProcess return parameters for the expectation previously defined by the When method
func (e *DecoderMockDecodeAndProcessExpectation[T]) Then(err error) *DecoderMock[T] {
	e.results = &DecoderMockDecodeAndProcessResults[T]{err}
	return e.mock
}

// Times sets number of times decoder.DecodeAndProcess should be invoked
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Times(n uint64) *mDecoderMockDecodeAndProcess[T] {
	if n == 0 {
		mmDecodeAndProcess.mock.t.Fatalf("Times of DecoderMock.DecodeAndProcess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDecodeAndProcess.expectedInvocations, n)
	return mmDecodeAndProcess
}

func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) invocationsDone() bool {
	if len(mmDecodeAndProcess.expectations) == 0 && mmDecodeAndProcess.defaultExpectation == nil && mmDecodeAndProcess.mock.funcDecodeAndProcess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDecodeAndProcess.mock.afterDecodeAndProcessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDecodeAndProcess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DecodeAndProcess implements decoder
func (mmDecodeAndProcess *DecoderMock[T]) DecodeAndProcess(r io.Reader, process func(T) error) (err error) {
	mm_atomic.AddUint64(&mmDecodeAndProcess.beforeDecodeAndProcessCounter, 1)
	defer mm_atomic.AddUint64(&mmDecodeAndProcess.afterDecodeAndProcessCounter, 1)

	if mmDecodeAndProcess.inspectFuncDecodeAndProcess != nil {
		mmDecodeAndProcess.inspectFuncDecodeAndProcess(r, process)
	}

	mm_params := DecoderMockDecodeAndProcessParams[T]{r, process}

	// Record call args
	mmDecodeAndProcess.DecodeAndProcessMock.mutex.Lock()
	mmDecodeAndProcess.DecodeAndProcessMock.callArgs = append(mmDecodeAndProcess.DecodeAndProcessMock.callArgs, &mm_params)
	mmDecodeAndProcess.DecodeAndProcessMock.mutex.Unlock()

	for _, e := range mmDecodeAndProcess.DecodeAndProcessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecodeAndProcess.DecodeAndProcessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecodeAndProcess.DecodeAndProcessMock.defaultExpectation.Counter, 1)
		mm_want := mmDecodeAndProcess.DecodeAndProcessMock.defaultExpectation.params
		mm_want_ptrs := mmDecodeAndProcess.DecodeAndProcessMock.defaultExpectation.paramPtrs

		mm_got := DecoderMockDecodeAndProcessParams[T]{r, process}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmDecodeAndProcess.t.Errorf("DecoderMock.DecodeAndProcess got unexpected parameter r, want: %#v, got: %#v%s\n", *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

			if mm_want_ptrs.process != nil && !minimock.Equal(*mm_want_ptrs.process, mm_got.process) {
				mmDecodeAndProcess.t.Errorf("DecoderMock.DecodeAndProcess got unexpected parameter process, want: %#v, got: %#v%s\n", *mm_want_ptrs.process, mm_got.process, minimock.Diff(*mm_want_ptrs.process, mm_got.process))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecodeAndProcess.t.Errorf("DecoderMock.DecodeAndProcess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecodeAndProcess.DecodeAndProcessMock.defaultExpectation.results
		if mm_results == nil {
			mmDecodeAndProcess.t.Fatal("No results are set for the DecoderMock.DecodeAndProcess")
		}
		return (*mm_results).err
	}
	if mmDecodeAndProcess.funcDecodeAndProcess != nil {
		return mmDecodeAndProcess.funcDecodeAndProcess(r, process)
	}
	mmDecodeAndProcess.t.Fatalf("Unexpected call to DecoderMock.DecodeAndProcess. %v %v", r, process)
	return
}

// DecodeAndProcessAfterCounter returns a count of finished DecoderMock.DecodeAndProcess invocations
func (mmDecodeAndProcess *DecoderMock[T]) DecodeAndProcessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAndProcess.afterDecodeAndProcessCounter)
}

// DecodeAndProcessBeforeCounter returns a count of DecoderMock.DecodeAndProcess invocations
func (mmDecodeAndProcess *DecoderMock[T]) DecodeAndProcessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAndProcess.beforeDecodeAndProcessCounter)
}

// Calls returns a list of arguments used in each call to DecoderMock.DecodeAndProcess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecodeAndProcess *mDecoderMockDecodeAndProcess[T]) Calls() []*DecoderMockDecodeAndProcessParams[T] {
	mmDecodeAndProcess.mutex.RLock()

	argCopy := make([]*DecoderMockDecodeAndProcessParams[T], len(mmDecodeAndProcess.callArgs))
	copy(argCopy, mmDecodeAndProcess.callArgs)

	mmDecodeAndProcess.mutex.RUnlock()

	return argCopy
}

// MinimockDecodeAndProcessDone returns true if the count of the DecodeAndProcess invocations corresponds
// the number of defined expectations
func (m *DecoderMock[T]) MinimockDecodeAndProcessDone() bool {
	if m.DecodeAndProcessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DecodeAndProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DecodeAndProcessMock.invocationsDone()
}

// MinimockDecodeAndProcessInspect logs each unmet expectation
func (m *DecoderMock[T]) MinimockDecodeAndProcessInspect() {
	for _, e := range m.DecodeAndProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DecoderMock.DecodeAndProcess with params: %#v", *e.params)
		}
	}

	afterDecodeAndProcessCounter := mm_atomic.LoadUint64(&m.afterDecodeAndProcessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DecodeAndProcessMock.defaultExpectation != nil && afterDecodeAndProcessCounter < 1 {
		if m.DecodeAndProcessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DecoderMock.DecodeAndProcess")
		} else {
			m.t.Errorf("Expected call to DecoderMock.DecodeAndProcess with params: %#v", *m.DecodeAndProcessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodeAndProcess != nil && afterDecodeAndProcessCounter < 1 {
		m.t.Error("Expected call to DecoderMock.DecodeAndProcess")
	}

	if !m.DecodeAndProcessMock.invocationsDone() && afterDecodeAndProcessCounter > 0 {
		m.t.Errorf("Expected %d calls to DecoderMock.DecodeAndProcess but found %d calls",
			mm_atomic.LoadUint64(&m.DecodeAndProcessMock.expectedInvocations), afterDecodeAndProcessCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DecoderMock[T]) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDecodeAndProcessInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DecoderMock[T]) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DecoderMock[T]) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDecodeAndProcessDone()
}
